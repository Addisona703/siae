# 前端文件上传指南

## 推荐方案：前端直接上传到Media服务 ✅

### 为什么选择这个方案？

1. **性能最优**：文件直接上传到MinIO，不经过业务服务
2. **解耦合**：文件上传和业务逻辑分离
3. **可扩展**：支持大文件、断点续传
4. **用户体验好**：可以显示实时上传进度

---

## 完整上传流程

### 流程图

```
┌─────────┐
│  前端   │
└────┬────┘
     │ 1. 初始化上传
     ↓
┌──────────────┐
│ Media服务    │
│ POST /uploads/init │
└────┬─────────┘
     │ 返回 uploadId + presignedUrl
     ↓
┌─────────┐
│  前端   │
└────┬────┘
     │ 2. 直接上传到MinIO
     ↓
┌──────────┐
│  MinIO   │
└────┬─────┘
     │ 上传成功
     ↓
┌─────────┐
│  前端   │
└────┬────┘
     │ 3. 通知完成
     ↓
┌──────────────┐
│ Media服务    │
│ POST /uploads/{uploadId}/complete │
└────┬─────────┘
     │ 返回 fileId
     ↓
┌─────────┐
│  前端   │
└────┬────┘
     │ 4. 保存到业务
     ↓
┌──────────────┐
│ User服务     │
│ PATCH /users/{id} │
│ { avatarFileId: fileId } │
└──────────────┘
```

---

## 代码示例

### 1. 基础版：小文件上传（< 100MB）

```javascript
/**
 * 上传头像到Media服务
 * @param {File} file - 文件对象
 * @param {Function} onProgress - 进度回调
 * @returns {Promise<string>} fileId
 */
async function uploadAvatar(file, onProgress) {
  const token = localStorage.getItem('token');
  
  // 步骤1：初始化上传
  const initResponse = await fetch('http://localhost:8040/api/v1/media/uploads/init', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify({
      filename: file.name,
      size: file.size,
      mime: file.type,
      bizTags: ['avatar', 'user']  // 业务标签
    })
  });
  
  const initResult = await initResponse.json();
  const { uploadId, presignedUrl } = initResult.data;
  
  // 步骤2：直接上传到MinIO
  const xhr = new XMLHttpRequest();
  
  return new Promise((resolve, reject) => {
    // 监听上传进度
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable && onProgress) {
        const percent = Math.round((e.loaded / e.total) * 100);
        onProgress(percent);
      }
    });
    
    xhr.addEventListener('load', async () => {
      if (xhr.status === 200) {
        // 步骤3：通知Media服务上传完成
        const completeResponse = await fetch(
          `http://localhost:8040/api/v1/media/uploads/${uploadId}/complete`,
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
              sha256: null  // 可选：文件哈希
            })
          }
        );
        
        const completeResult = await completeResponse.json();
        resolve(completeResult.data.fileId);
      } else {
        reject(new Error('Upload failed'));
      }
    });
    
    xhr.addEventListener('error', () => reject(new Error('Upload error')));
    
    xhr.open('PUT', presignedUrl);
    xhr.setRequestHeader('Content-Type', file.type);
    xhr.send(file);
  });
}

// 使用示例
async function updateUserAvatar(userId, avatarFile) {
  try {
    // 显示上传进度
    const fileId = await uploadAvatar(avatarFile, (percent) => {
      console.log(`上传进度: ${percent}%`);
      updateProgressBar(percent);
    });
    
    console.log('文件上传成功，fileId:', fileId);
    
    // 更新用户头像
    await fetch(`http://localhost:8020/api/v1/user/users/${userId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      },
      body: JSON.stringify({
        avatarFileId: fileId
      })
    });
    
    console.log('用户头像更新成功');
  } catch (error) {
    console.error('上传失败:', error);
  }
}
```

### 2. 进阶版：大文件分片上传（> 100MB）

```javascript
/**
 * 大文件分片上传
 * @param {File} file - 文件对象
 * @param {Function} onProgress - 进度回调
 * @returns {Promise<string>} fileId
 */
async function uploadLargeFile(file, onProgress) {
  const token = localStorage.getItem('token');
  const CHUNK_SIZE = 5 * 1024 * 1024; // 5MB per chunk
  const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
  
  // 步骤1：初始化分片上传
  const initResponse = await fetch('http://localhost:8040/api/v1/media/uploads/init', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`
    },
    body: JSON.stringify({
      filename: file.name,
      size: file.size,
      mime: file.type,
      multipart: true,  // 启用分片上传
      partCount: totalChunks
    })
  });
  
  const initResult = await initResponse.json();
  const { uploadId, parts } = initResult.data;
  
  // 步骤2：上传每个分片
  const uploadedParts = [];
  
  for (let i = 0; i < totalChunks; i++) {
    const start = i * CHUNK_SIZE;
    const end = Math.min(start + CHUNK_SIZE, file.size);
    const chunk = file.slice(start, end);
    
    // 上传分片到MinIO
    const partUrl = parts[i].presignedUrl;
    const response = await fetch(partUrl, {
      method: 'PUT',
      body: chunk,
      headers: {
        'Content-Type': file.type
      }
    });
    
    // 获取ETag
    const etag = response.headers.get('ETag');
    uploadedParts.push({
      partNumber: i + 1,
      etag: etag
    });
    
    // 更新进度
    if (onProgress) {
      const percent = Math.round(((i + 1) / totalChunks) * 100);
      onProgress(percent);
    }
  }
  
  // 步骤3：完成分片上传
  const completeResponse = await fetch(
    `http://localhost:8040/api/v1/media/uploads/${uploadId}/complete`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        parts: uploadedParts
      })
    }
  );
  
  const completeResult = await completeResponse.json();
  return completeResult.data.fileId;
}
```

### 3. React组件示例

```jsx
import React, { useState } from 'react';
import { Upload, Button, Progress, message } from 'antd';
import { UploadOutlined } from '@ant-design/icons';

function AvatarUpload({ userId, onSuccess }) {
  const [uploading, setUploading] = useState(false);
  const [progress, setProgress] = useState(0);

  const handleUpload = async (file) => {
    setUploading(true);
    setProgress(0);

    try {
      // 上传文件
      const fileId = await uploadAvatar(file, (percent) => {
        setProgress(percent);
      });

      // 更新用户头像
      await fetch(`/api/v1/user/users/${userId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        },
        body: JSON.stringify({
          avatarFileId: fileId
        })
      });

      message.success('头像上传成功');
      onSuccess && onSuccess(fileId);
    } catch (error) {
      message.error('头像上传失败');
      console.error(error);
    } finally {
      setUploading(false);
      setProgress(0);
    }

    return false; // 阻止默认上传行为
  };

  return (
    <div>
      <Upload
        beforeUpload={handleUpload}
        showUploadList={false}
        accept="image/*"
      >
        <Button icon={<UploadOutlined />} loading={uploading}>
          {uploading ? '上传中...' : '上传头像'}
        </Button>
      </Upload>
      
      {uploading && (
        <Progress percent={progress} status="active" />
      )}
    </div>
  );
}

export default AvatarUpload;
```

### 4. Vue组件示例

```vue
<template>
  <div class="avatar-upload">
    <el-upload
      :before-upload="handleUpload"
      :show-file-list="false"
      accept="image/*"
    >
      <el-button :loading="uploading" type="primary">
        <i class="el-icon-upload"></i>
        {{ uploading ? '上传中...' : '上传头像' }}
      </el-button>
    </el-upload>
    
    <el-progress
      v-if="uploading"
      :percentage="progress"
      :status="progress === 100 ? 'success' : ''"
    />
  </div>
</template>

<script>
export default {
  name: 'AvatarUpload',
  props: {
    userId: {
      type: Number,
      required: true
    }
  },
  data() {
    return {
      uploading: false,
      progress: 0
    };
  },
  methods: {
    async handleUpload(file) {
      this.uploading = true;
      this.progress = 0;

      try {
        // 上传文件
        const fileId = await uploadAvatar(file, (percent) => {
          this.progress = percent;
        });

        // 更新用户头像
        await this.$http.patch(`/api/v1/user/users/${this.userId}`, {
          avatarFileId: fileId
        });

        this.$message.success('头像上传成功');
        this.$emit('success', fileId);
      } catch (error) {
        this.$message.error('头像上传失败');
        console.error(error);
      } finally {
        this.uploading = false;
        this.progress = 0;
      }

      return false; // 阻止默认上传
    }
  }
};
</script>
```

---

## 处理孤儿文件

### 方案1：前端取消上传时清理

```javascript
async function uploadWithCleanup(file, onProgress) {
  let uploadId = null;
  
  try {
    // 初始化上传
    const initResult = await initUpload(file);
    uploadId = initResult.uploadId;
    
    // 上传文件
    await uploadToMinio(file, initResult.presignedUrl, onProgress);
    
    // 完成上传
    const fileId = await completeUpload(uploadId);
    return fileId;
    
  } catch (error) {
    // 如果失败，中断上传并清理
    if (uploadId) {
      await abortUpload(uploadId);
    }
    throw error;
  }
}

async function abortUpload(uploadId) {
  await fetch(`http://localhost:8040/api/v1/media/uploads/${uploadId}/abort`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${localStorage.getItem('token')}`
    }
  });
}
```

### 方案2：后端定时清理

Media服务会自动清理超过24小时未完成的上传。

---

## 最佳实践

### 1. 文件类型验证

```javascript
function validateFile(file) {
  // 验证文件类型
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  if (!allowedTypes.includes(file.type)) {
    throw new Error('不支持的文件类型');
  }
  
  // 验证文件大小（10MB）
  const maxSize = 10 * 1024 * 1024;
  if (file.size > maxSize) {
    throw new Error('文件大小不能超过10MB');
  }
  
  return true;
}
```

### 2. 图片压缩

```javascript
async function compressImage(file, maxWidth = 800) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        let width = img.width;
        let height = img.height;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        canvas.toBlob((blob) => {
          resolve(new File([blob], file.name, { type: 'image/jpeg' }));
        }, 'image/jpeg', 0.8);
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });
}

// 使用
const compressedFile = await compressImage(originalFile);
const fileId = await uploadAvatar(compressedFile);
```

### 3. 错误处理

```javascript
async function uploadWithRetry(file, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await uploadAvatar(file);
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;
      }
      console.log(`上传失败，重试 ${i + 1}/${maxRetries}`);
      await sleep(1000 * (i + 1)); // 指数退避
    }
  }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

---

## 总结

✅ **推荐流程**：
1. 前端直接上传到Media服务
2. 获取fileId
3. 将fileId保存到User服务

✅ **优点**：
- 性能最优
- 架构清晰
- 易于扩展

✅ **你的Media服务已经完美支持这个流程！**
